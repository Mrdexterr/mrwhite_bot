import os
import time
import logging
from pyrogram import Client, filters, emoji
from pyrogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from pyrogram.enums import ChatType
from pyrogram.errors import UserNotParticipant
from info import START_MSG, CHANNELS, ADMINS, INVITE_MSG, AUTH_USERS, AUTH_CHANNEL, MAX_RESULTS, WHITE_CHANNELS
from utils import Media, get_search_results, InlineQueryResultCachedDocument
from utils.helpers import sizeof_fmt

logger = logging.getLogger(__name__)


@Client.on_message(filters.command('start'))
async def start(bot, message):
    """Start command handler"""
    if len(message.command) > 1:
        if message.command[1] == 'subscribe' or (AUTH_CHANNEL and not await is_subscribed(bot, message)):
            await message.reply(INVITE_MSG)
        else:
            video_id = message.command[1]
            result = await Media.collection.find_one({"_id": video_id})
            if not result:
                return
            file_type = result['file_type']
            if file_type == "video":
                await bot.send_video(message.from_user.id, video_id, caption=f"{result['caption']}\n\n**Generated by @FilmHunterr_Bot‚ù§Ô∏è**")
            else:
                await bot.send_document(message.from_user.id, video_id, caption=f"{result['caption']}**Generated by @FilmHunterr_Bot‚ù§Ô∏è**")
    else:
        buttons = [[
            InlineKeyboardButton(
                   "Add To Your Group",
                   url=f"http://t.me/filmhunterr_bot?startgroup=true"
                   )]
                   ]
        reply_markup = InlineKeyboardMarkup(buttons)
        if (message.chat.type == ChatType.GROUP or message.chat.type == ChatType.SUPERGROUP):
            await message.reply(START_MSG.format(name=message.from_user.first_name))
        else:
            await message.reply(START_MSG.format(name=message.from_user.first_name), reply_markup=reply_markup)


@Client.on_message(filters.command('channel') & filters.user(ADMINS))
async def channel_info(bot, message):
    """Send basic information of channel"""
    if isinstance(CHANNELS, (int, str)):
        channels = [CHANNELS]
    elif isinstance(CHANNELS, list):
        channels = CHANNELS
    else:
        raise ValueError("Unexpected type of CHANNELS")

    text = 'üìë **Indexed channels/groups**\n'
    for channel in channels:
        chat = await bot.get_chat(channel)
        if chat.username:
            text += '\n@' + chat.username
        else:
            text += '\n' + chat.title or chat.first_name

    text += f'\n\n**Total:** {len(CHANNELS)}'

    if len(text) < 4096:
        await message.reply(text)
    else:
        file = 'Indexed channels.txt'
        with open(file, 'w') as f:
            f.write(text)
        await message.reply_document(file)
        os.remove(file)


@Client.on_message(filters.command('total') & filters.user(ADMINS))
async def total(bot, message):
    """Show total files in database"""
    msg = await message.reply("Processing...‚è≥", quote=True)
    try:
        total = await Media.count_documents()
        await msg.edit(f'üìÅ Saved files: {total}')
    except Exception as e:
        logger.exception('Failed to check total files')
        await msg.edit(f'Error: {e}')


@Client.on_message(filters.command('logger') & filters.user(ADMINS))
async def log_file(bot, message):
    """Send log file"""
    try:
        await message.reply_document('TelegramBot.log')
    except Exception as e:
        await message.reply(str(e))


@Client.on_message(filters.command('delete') & filters.user(ADMINS))
async def delete(bot, message):
    """Delete file from database"""
    reply = message.reply_to_message
    if reply and reply.media:
        msg = await message.reply("Processing...‚è≥", quote=True)
    else:
        await message.reply('Reply to file with /delete which you want to delete', quote=True)
        return

    for file_type in ("document", "video", "audio"):
        media = getattr(reply, file_type, None)
        if media is not None:
            break
    else:
        await msg.edit('This is not supported file format')
        return

    result = await Media.collection.delete_one({
        'file_name': media.file_name,
        'file_size': media.file_size,
        'mime_type': media.mime_type,
        'caption': reply.caption.html if reply.caption else None
    })
    if result.deleted_count:
        await msg.edit('File is successfully deleted from database')
    else:
        await msg.edit('File not found in database')

# (filters.user(AUTH_USERS) if AUTH_USERS else None)


@Client.on_message(filters.private | filters.group)
async def search(bot, message):
    if (WHITE_CHANNELS and (message.chat.type == ChatType.GROUP or message.chat.type == ChatType.SUPERGROUP) and message.chat.id not in WHITE_CHANNELS) or not message.text:
        return
    if AUTH_CHANNEL and not await is_subscribed(bot, message):
        await message.reply(INVITE_MSG, quote=True)
        return
    msg = await message.reply(f"**Searching for `{message.text}`...‚è≥**", quote=True)
    results = []

    if '|' in message.text:
        text, file_type = message.text.split('|', maxsplit=1)
        text = text.strip()
        file_type = file_type.strip().lower()
    else:
        text = message.text.strip()
        file_type = None

    offset = 0
    files, next_offset, total = await get_search_results(text, file_type=file_type, max_results=MAX_RESULTS, offset=offset)
    for file in files:
        if message.chat.type == ChatType.GROUP or message.chat.type == ChatType.SUPERGROUP:
            results.append([
                InlineKeyboardButton(
                    f"[{sizeof_fmt(file.file_size)}] {file.file_name}",
                    url=f"https://t.me/FilmHunterr_Bot?start={file.file_id}"
                )]
            )
        else:
            results.append([
                InlineKeyboardButton(
                    f"[{sizeof_fmt(file.file_size)}] {file.file_name}",
                    callback_data=f"{file.file_id}"
                )]
            )

    if results:
        if next_offset and len(results) != total:
            results.append(
                [
                    InlineKeyboardButton(
                        "Next >",
                        callback_data=f"nxtprev_{next_offset}"
                    )
                ]
            )
        reply_markup = InlineKeyboardMarkup(results)
        await msg.edit(f"**Results**", reply_markup=reply_markup)
        return
    else:
        no_re = await msg.edit("""**üòå …™Íú∞ ·¥õ ú·¥á ·¥ç·¥è·¥†…™·¥á  è·¥è·¥ú ·¥Ä Ä·¥á  ü·¥è·¥è·¥ã…™…¥…¢ Íú∞·¥è Ä …™s …¥·¥è·¥õ ·¥Ä·¥†·¥Ä…™ ü·¥Ä ô ü·¥á ·¥õ ú·¥á…¥  ü·¥á·¥Ä·¥†·¥á ·¥Ä ·¥ç·¥áss·¥Ä…¢·¥á  ô·¥á ü·¥è·¥° üòå 

·¥áx·¥Ä·¥ç·¥ò ü·¥á : 
·¥á…¥·¥õ·¥á Ä  è·¥è·¥ú Ä ·¥ç·¥è·¥†…™·¥á …¥·¥Ä·¥ç·¥á ( è·¥á·¥Ä Ä) ·¥õ·¥Ä…¢ @admin**""")
        if message.chat.type == "group" or message.chat.type == "supergroup":
            time.sleep(10)
            await no_re.delete()
        return


@Client.on_callback_query(filters.regex(r"nxtprev_(.*)"))
async def nxt_prv(bot, callback_query):
    msg_text = callback_query.message.reply_to_message.text
    if '|' in msg_text:
        text, file_type = msg_text.split('|', maxsplit=1)
        text = text.strip()
        file_type = file_type.strip().lower()
    else:
        text = msg_text.strip()
        file_type = None
    offset = int(callback_query.matches[0].group(1))
    files, next_offset, total = await get_search_results(text, file_type=file_type, max_results=MAX_RESULTS, offset=offset)
    results = []
    for file in files:
        if callback_query.message.chat.type == ChatType.GROUP or callback_query.message.chat.type == ChatType.SUPERGROUP:
            results.append([
                InlineKeyboardButton(
                    f"[{sizeof_fmt(file.file_size)}] {file.file_name}",
                    url=f"https://t.me/FilmHunterr_Bot?start={file.file_id}"
                )]
            )
        else:
            results.append([
                InlineKeyboardButton(
                    f"[{sizeof_fmt(file.file_size)}] {file.file_name}",
                    callback_data=file.file_id
                )]
            )
    nxt_prv_button = []
    if offset:
        nxt_prv_button.append(InlineKeyboardButton(
            "< Previous",
            callback_data=f"nxtprev_{offset - MAX_RESULTS}"
        ))
    if next_offset and total != next_offset:
        nxt_prv_button.append(InlineKeyboardButton(
            "Next >",
            callback_data=f"nxtprev_{next_offset}"
        ))
    results.append(nxt_prv_button)

    reply_markup = InlineKeyboardMarkup(results)
    await callback_query.message.edit(f"**Results**", reply_markup=reply_markup)
    await callback_query.answer()


@Client.on_callback_query(filters.user(AUTH_USERS) if AUTH_USERS else None)
async def answer_query(bot, callback_query):
    video_id = callback_query.data
    result = await Media.collection.find_one({"_id": video_id})
    if not result:
        return
    file_type = result['file_type']
    if file_type == "video":
        await bot.send_video(callback_query.from_user.id, video_id, caption=f"{result['caption']}\n\n**Generated by @FilmHunterr_Bot‚ù§Ô∏è**")
    else:
        await bot.send_document(callback_query.from_user.id, video_id, caption=f"{result['caption']}\n\n**Generated by @FilmHunterr_Bot‚ù§Ô∏è**")
    await callback_query.answer()


async def is_subscribed(bot, message):
    try:
        user = await bot.get_chat_member(AUTH_CHANNEL, message.from_user.id)
    except UserNotParticipant:
        pass
    except Exception as e:
        logger.exception(e)
    else:
        if not user.status == 'kicked':
            return True

    return False
